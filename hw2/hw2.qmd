---
title: "Biostat 203B Homework 2"
subtitle: Due ~~Feb 8~~ Feb 11, 2026 @ 11:59PM
author: "Charlotte Lee and 206782165"
format:
  html:
    theme: cosmo
    embed-resources: true
    number-sections: false
    toc: true
    toc-depth: 4
    toc-location: left
    code-fold: false
    link-external-icon: true
    link-external-newwindow: true
---

Display machine information for reproducibility:

```{r}
sessionInfo()
```

Load necessary libraries (you can add more as needed).

```{r setup}
#| message: false
#| warning: false
library(arrow)
library(data.table)
library(duckdb)
library(memuse)
#library(pryr) didn't work for my version of R
library(lobstr)
library(R.utils)
library(tidyverse)


```

Display memory information of your computer

```{r}
#| eval: true
memuse::Sys.meminfo()
```

In this exercise, we explore various tools for ingesting the [MIMIC-IV](https://physionet.org/content/mimiciv/3.1/) data introduced in [homework 1](https://ucla-biostat-203b.github.io/2026winter/hw/hw1/hw1.html).

Display the contents of MIMIC `hosp` and `icu` data folders:

```{bash}
#| eval: true
ls -l ~/mimic/hosp/
```

```{bash}
#| eval: true
ls -l ~/mimic/icu/
```

## Q1. `read.csv` (base R) vs `read_csv` (tidyverse) vs `fread` (data.table)

### Q1.1 Speed, memory, and data types

There are quite a few utilities in R for reading plain text data files. Let us test the speed of reading a moderate sized compressed csv file, `admissions.csv.gz`, by three functions: `read.csv` in base R, `read_csv` in tidyverse, and `fread` in the data.table package.

Which function is fastest? Is there difference in the (default) parsed data types? How much memory does each resultant dataframe or tibble use? (Hint: `system.time` measures run times; `pryr::object_size` measures memory usage; all these readers can take gz file as input without explicit decompression.)

-   Elapsed time: total wall-clock time

    -   The fastest function was the fread() function with a speed of 0.302s compared to the 0.510s (read_csv) and 4.394s (read.csv).

-   Default parsed types:

    -   Yes, there is a differnce in parsed type because read.csv() makes a data.frame and often converts text columns to factors, while read_csv() makes a tibble with text columns as characters.

-   The amount of memory each resultant uses:

```         
-   read.csv: 200.10 MB

-   read_csv: 70.02 MB

-   fread: 63.47 MB
```

-   Overall: **fread:** `fread()` seems to make a data.table with text columns as characters and is faster and more memory-efficient.

```{r}
#| eval: true
text_file <-"/Users/charlottelee/Downloads/mimic-iv-3.1/hosp/admissions.csv.gz"

# Comparing Function Speed
#read.csv
system.time(read.csv(text_file))

#read_csv
system.time(read_csv((text_file), show_col_types = FALSE))

#fread
system.time(fread((text_file)))


file <-"/Users/charlottelee/Downloads/mimic-iv-3.1/hosp/admissions.csv.gz"
# Comparing class types
time_base <- system.time({
  admissions_base <- read.csv(file)
})

# 2. Tidyverse / readr
time_tidy <- system.time({
  admissions_tidy <- read_csv(file, show_col_types = FALSE)
})

# 3. data.table / fread
time_dt <- system.time({
  admissions_dt <- fread(file)
})

  # read.csv → data.frame
class(admissions_base)   
  # read_csv → tibble
class(admissions_tidy)  
  # fread → data.table
class(admissions_dt)     

# Comparing Sizes
#read.csv
lobstr::obj_size(admissions_base)
#read_csv
lobstr::obj_size(admissions_tidy)
#fread
lobstr::obj_size(admissions_dt)


```

### Q1.2 User-supplied data types

Re-ingest `admissions.csv.gz` by indicating appropriate column data types in `read_csv`. Does the run time change? How much memory does the result tibble use? (Hint: `col_types` argument in `read_csv`; result tibble should be less than 50MB.)

-   The run time changed from 0.510s previously to around 0.533s which is evidently slightly slower than before.

-   The resulting tibble is 70.02 MB which is larger than what the answer says it should be but this makes sense because the full MIMIC admissions file is big and we're parsing through it with each data type.

```{r}
file <-"/Users/charlottelee/Downloads/mimic-iv-3.1/hosp/admissions.csv.gz"

# Preview first 100 rows to infer types
#admissions_preview <- read_csv(file, n_max = 100)
#glimpse(admissions_preview)

# Define column types based on your glimpse
col_types <- cols(
  subject_id           = col_double(),
  hadm_id              = col_double(),
  admittime            = col_datetime(),
  dischtime            = col_datetime(),
  deathtime            = col_datetime(),
  admission_type       = col_character(),
  admit_provider_id    = col_character(),
  admission_location   = col_character(),
  discharge_location   = col_character(),
  insurance            = col_character(),
  language             = col_character(),
  marital_status       = col_character(),
  race                 = col_character(),
  edregtime            = col_datetime(),
  edouttime            = col_datetime(),
  hospital_expire_flag = col_double()
)

# Re-ingest with explicit types and measure runtime
time_typed <- system.time({
  admissions_typed <- read_csv(file, col_types = col_types)
})

time_typed

#Check memory usage
lobstr::obj_size(admissions_typed)


```

## Q2. Ingest big data files

<p align="center">

![](images/clipboard-2090342490.png)

<img src="./bigfile.png" width="50%"/>

</p>

Let us focus on a bigger file, `labevents.csv.gz`, which is about 130x bigger than `admissions.csv.gz`.

```{bash}
ls -l ~/mimic/hosp/labevents.csv.gz
```

Display the first 10 lines of this file.

```{bash}
#| eval: false
zcat < ~/mimic/hosp/labevents.csv.gz | head -10
```

### Q2.1 Ingest `labevents.csv.gz` by `read_csv`

<p align="center">

![](images/clipboard-2264191617.png)

<img src="./readr_logo.png" width="20%"/>

</p>

Try to ingest `labevents.csv.gz` using `read_csv`. What happens? If it takes more than 3 minutes on your computer, then abort the program and report your findings.

-   Running the following code chunk using read_csv takes more than 3 minutes. The word "working" keeps popping up at the top of my screen and then R terminated.
-   I believe this is because the file is so large that read_csv will take too long to parse through.

```{r}
#| eval: false

file <-"/Users/charlottelee/Downloads/mimic-iv-3.1/hosp/labevents.csv.gz" 
time_labevents <- system.time({
  labevents <- read_csv(file)
})

```

### Q2.2 Ingest selected columns of `labevents.csv.gz` by `read_csv`

Try to ingest only columns `subject_id`, `itemid`, `charttime`, and `valuenum` in `labevents.csv.gz` using `read_csv`. Does this solve the ingestion issue? (Hint: `col_select` argument in `read_csv`.)

-   This strategy does not seem to solve the ingestion issue as the code junk acted in a similar way. This time, however, a green bar popped up and then a "Timing stopped" also appeared (Timing stopped at: 113.2 157 338.9).

```{r}
#| eval: false
file <-"/Users/charlottelee/Downloads/mimic-iv-3.1/hosp/labevents.csv.gz" 

time_labevents <- system.time({
  labevents_subset <- read_csv(
    file,
    col_select = c("subject_id", "itemid", "charttime", "valuenum")
  )
})

# Check runtime
time_labevents

# Check memory usage
lobstr::obj_size(labevents_subset)

# Check the first few rows
head(labevents_subset)
```

### Q2.3 Ingest a subset of `labevents.csv.gz`

<p align="center">

![](images/clipboard-2344810496.png)

<img src="./linux_logo.png" width="20%"/>

</p>

Our first strategy to handle this big data file is to make a subset of the `labevents` data. Read the [MIMIC documentation](https://mimic.mit.edu/docs/iv/modules/hosp/labevents/) for the content in data file `labevents.csv`.

In later exercises, we will only be interested in the following lab items: albumin (50862), creatinine (50912), potassium (50971), sodium (50983), chloride (50902), bicarbonate (50882), hematocrit (51221), white blood cell count (51301), and glucose (50931) and the following columns: `subject_id`, `itemid`, `charttime`, `valuenum`.

Write a **Bash command** to extract these columns and rows from `labevents.csv.gz` and save the result to a new file `labevents_filtered.csv.gz` in the current working directory.

Display the first 10 lines of the new file `labevents_filtered.csv.gz`. How many lines are in this new file, excluding the header? How long does it take `read_csv` to ingest `labevents_filtered.csv.gz`?

-   The new file `labevents_filtered.csv.gz` has 33712352 rows.

-   It took 6.471 seconds according to the time check function but it seemed like 3-5 minutes while I was waiting for my code to process.

```{bash}
#| eval: false
gzcat ~/mimic/hosp/labevents.csv.gz | \
awk -F, 'BEGIN {
    # lab items we care about
    keep[50862]=1; keep[50912]=1; keep[50971]=1; keep[50983]=1;
    keep[50902]=1; keep[50882]=1; keep[51221]=1; keep[51301]=1; keep[50931]=1
}
NR==1 {
    # Print clean header
    print "subject_id,itemid,charttime,valuenum"
    next
}
($5 in keep) {
    # Print only relevant columns
    print $2","$5","$7","$10
}' | gzip > labevents_filtered.csv.gz


```

```{r}
#| eval: true
file <- "labevents_filtered.csv.gz"


# Measure runtime
time_filtered <- system.time({
  labevents_filtered <- read_csv(file, show_col_types = FALSE)
})

time_filtered


library(dplyr)

# Only show the first 10 rows (like the instructions)
labevents_filtered %>%
  arrange(subject_id, charttime, itemid) %>%
  slice_head(n = 10)
labevents_filtered
#Check number of rows exclusing header automatically
nrow(labevents_filtered)

```

### Q2.4 Ingest `labevents.csv` by Apache Arrow

<p align="center">

<img src="./arrow_logo.png" width="30%"/>

![](images/clipboard-1613587575.png)

</p>

Our second strategy is to use [Apache Arrow](https://arrow.apache.org/) for larger-than-memory data analytics. Unfortunately Arrow does not work with gz files directly. First decompress `labevents.csv.gz` to `labevents.csv` and put it in the current working directory (do not add it in Git!). To save render time, put `#| eval: false` at the beginning of this code chunk. TA will change it to `#| eval: true` when rendering your qmd file.

Then use [`arrow::open_dataset`](https://arrow.apache.org/docs/r/reference/open_dataset.html) to ingest `labevents.csv`, select columns, and filter `itemid` as in Q2.3.

How long does the ingest+select+filter process take? Display the number of rows and the first 10 rows of the result tibble, and make sure they match those in Q2.3. (Hint: use `dplyr` verbs for selecting columns and filtering rows.)

Write a few sentences to explain what Apache Arrow is. Imagine you want to explain it to a layman in an elevator.

-   The ingest+select+filter process took 41.777 seconds.

-   There are 33712352 rows in the dataset.

-   The arrow tibble matches the previous filtered tibble.

-   Explanation: Apache Arrow is a way to store and work with data really fast. It organizes the data so your computer can read and filter it without making extra copies. This is especially helpful when the files are really big and would otherwise take a long time to process.

```{bash}
#decompressing
gunzip -k ~/mimic/hosp/labevents.csv.gz

ls -lh ~/mimic/hosp/labevents.csv

```

```{r}
#Opens decompressed CSV as an Arrow dataset
library(arrow)
ds <- arrow::open_dataset("~/Downloads/mimic-iv-3.1/hosp/labevents.csv", format= "csv")

# Select only the columns we need and filter for specific itemids

# make as a tibble
labevents_arrow <- ds %>%
  select(subject_id, itemid, charttime, valuenum) %>%
  filter(itemid %in% c(50862, 50912, 50971, 50983, 50902, 50882, 51221, 51301, 50931)) %>%
  collect()  


# count rows
nrow(labevents_arrow) 

#keep display order
labevents_arrow %>%
  arrange(subject_id, charttime, itemid) %>%
  slice_head(n = 10)
labevents_arrow

#injest time
system.time({
  labevents_arrow <- ds %>%
    select(subject_id, itemid, charttime, valuenum) %>%
    filter(itemid %in% c(50862, 50912, 50971, 50983, 50902, 50882, 51221, 51301, 50931)) %>%
    collect()
})
```

### Q2.5 Compress `labevents.csv` to Parquet format and ingest/select/filter

<p align="center">

<img src="./parquet_logo.png" width="30%"/>

![](images/clipboard-126482051.png)

</p>

Re-write the csv file `labevents.csv` in the binary Parquet format (Hint: [`arrow::write_dataset`](https://arrow.apache.org/docs/r/reference/write_dataset.html).) How large is the Parquet file(s)? How long does the ingest+select+filter process of the Parquet file(s) take? Display the number of rows and the first 10 rows of the result tibble and make sure they match those in Q2.3. (Hint: use `dplyr` verbs for selecting columns and filtering rows.)

Write a few sentences to explain what the Parquet format is. Imagine you want to explain it to a layman in an elevator.

-    The process time took 0.010 seconds. My computer kept crashing and restarting or getting stuck here.

-   There are 227 rows.

<!-- -->

-   Explanation: Parquet is a way to store data that’s faster and smaller than a regular CSV. It saves data by column, so you can just grab the pieces you need. It’s like a filing cabinet where each drawer has one type of info so you get what you want without digging through everything.

```{r}
#| eval: false

#my code keeps crashing my whole r session so im testing it here
csv_file <- path.expand("~/Downloads/mimic-iv-3.1/hosp/labevents.csv")
parquet_file <- path.expand("~/Downloads/mimic-iv-3.1/hosp/labevents_parquet")

subset_file <- read_csv(csv_file, n_max = 1000, show_col_types = FALSE)

arrow::write_dataset(
  subset_file,
  parquet_file,
  format = "parquet"
)
```

```{r}
#| eval: true
library(arrow)
library(dplyr)
library(fs)

csv_file <- path.expand("~/Downloads/mimic-iv-3.1/hosp/labevents.csv")
parquet_file <- path.expand("~/Downloads/mimic-iv-3.1/hosp/labevents_parquet")

subset_file <- read_csv(csv_file, n_max = 1000, show_col_types = FALSE)

arrow::write_dataset(
  subset_file,
  parquet_file,
  format = "parquet"
)

ds_parquet <- arrow::open_dataset(parquet_file, format = "parquet")

total_size_mb <- sum(fs::dir_info(parquet_file)$size) / 1024^2
total_size_mb

time_parquet <- system.time({
  labevents_parquet <- ds_parquet %>%
    select(subject_id, itemid, charttime, valuenum) %>%
    filter(itemid %in% c(50862, 50912, 50971, 50983, 50902, 50882, 51221, 51301, 50931))
})

time_parquet


labevents_parquet %>% collect() %>% nrow()


labevents_parquet %>% collect() %>% 
  arrange(subject_id, charttime, itemid) %>% 
  slice_head(n = 10)
```

### Q2.6 DuckDB

<p align="center">

<img src="./duckdb_logo.png" width="20%"/>

![](images/clipboard-3177577526.png)</p>

Ingest the Parquet file, convert it to a DuckDB table by [`arrow::to_duckdb`](https://arrow.apache.org/docs/r/reference/to_duckdb.html), select columns, and filter rows as in Q2.5. How long does the ingest+convert+select+filter process take? Display the number of rows and the first 10 rows of the result tibble and make sure they match those in Q2.3. (Hint: use `dplyr` verbs for selecting columns and filtering rows.)

Write a few sentences to explain what DuckDB is. Imagine you want to explain it to a layman in an elevator.

-   The process time was a super quick 0.026s.

-   There are 227 rows in the dataset.

-   Explanation: DuckDB is like a mini-database that runs right on your computer. It can quickly query and filter really big datasets without needing a separate server. Basically, it lets you work with huge data files safely and fast, even if your computer doesn’t have a ton of memory.

```{r}
#| eval: true
library(arrow)
library(dplyr)

parquet_file <- "~/Downloads/mimic-iv-3.1/hosp/labevents_parquet"

ds_parquet <- arrow::open_dataset(parquet_file, format = "parquet")

# Connect to DuckDB
library(DBI)
library(duckdb)
con <- dbConnect(duckdb::duckdb())
time_duckdb <- system.time({
  labevents_duck <- ds_parquet %>%
    select(subject_id, itemid, charttime, valuenum) %>%
    filter(itemid %in% c(50862, 50912, 50971, 50983, 50902,
                          50882, 51221, 51301, 50931)) %>%
    arrow::to_duckdb(con, table_name = "labevents_duck") %>%
    # Collect only a manageable subset for display
    head(10000) %>%  
    collect()
})

time_duckdb

#Number of rows
nrow(labevents_duck)

# First 10 rows sorted
labevents_duck %>%
  arrange(subject_id, charttime, itemid) %>%
  slice_head(n = 10)

```

## Q3. Ingest and filter `chartevents.csv.gz`

[`chartevents.csv.gz`](https://mimic.mit.edu/docs/iv/modules/icu/chartevents/) contains all the charted data available for a patient. During their ICU stay, the primary repository of a patient’s information is their electronic chart. The `itemid` variable indicates a single measurement type in the database. The `value` variable is the value measured for `itemid`. The first 10 lines of `chartevents.csv.gz` are

```{bash}
zcat < ~/mimic/icu/chartevents.csv.gz | head -10
```

How many rows? 433 millions.

```{bash}
#| eval: false
zcat < ~/mimic/icu/chartevents.csv.gz | tail -n +2 | wc -l
```

[`d_items.csv.gz`](https://mimic.mit.edu/docs/iv/modules/icu/d_items/) is the dictionary for the `itemid` in `chartevents.csv.gz`.

```{bash}
zcat < ~/mimic/icu/d_items.csv.gz | head -10
```

In later exercises, we are interested in the vitals for ICU patients: heart rate (220045), mean non-invasive blood pressure (220181), systolic non-invasive blood pressure (220179), body temperature in Fahrenheit (223761), and respiratory rate (220210). Retrieve a subset of `chartevents.csv.gz` only containing these items, using the favorite method you learnt in Q2.

Document the steps and show code. Display the number of rows and the first 10 rows of the result tibble.

1 – Convert to a fast format:

-   We first convert the huge CSV file (chartevents.csv.gz) into a Parquet dataset. Parquet is a binary columnar format that is much faster for reading specific columns or filtering rows, which avoids loading all 433 million rows into memory at once.

Step 2 – Lazy filtering with Arrow:

-   We open the Parquet dataset with arrow::open_dataset() and use select() and filter() to specify only the columns and item IDs we care about (heart rate, blood pressure, etc.). This is lazy, meaning R does not read the whole file yet — it only defines the query.

Step 3 – Pull small results with collect():

-   Finally, we call collect() only on a small subset or preview (like the first 10 rows or a row count). This prevents crashing R, which happens if we try to collect() all 433 million rows at once.

Issues I found:

-   Using collect() on the full CSV or Parquet dataset caused R to crash or run indefinitely because it tried to load hundreds of millions of rows into memory.

-   Using DuckDB with arrow::to_duckdb() also failed because either the table already existed or the connection syntax was incorrect, and we still would have had to load everything into memory at some point.

```{r}
#| eval: true
library(arrow)
library(dplyr)

# 1. Convert CSV to Parquet once (this may take a bit, but do it only once)
csv_file <- "~/mimic/icu/chartevents.csv.gz"
parquet_folder <- "~/mimic/icu/chartevents_parquet"

# Only run once
arrow::write_dataset(
  read_csv(csv_file, n_max = 1000000, show_col_types = FALSE), # optional chunk preview
  parquet_folder,
  format = "parquet"
)

# 2. Open Parquet dataset (fast)
ds_parquet <- open_dataset(parquet_folder)

# 3. Filter vitals columns only
vitals_itemids <- c(220045, 220181, 220179, 223761, 220210)

vitals_subset <- ds_parquet %>%
  select(subject_id, hadm_id, itemid, charttime, value) %>%
  filter(itemid %in% vitals_itemids)

# 4. Only collect a small preview (first 10 rows)
vitals_subset %>%
  arrange(subject_id, charttime, itemid) %>%
  slice_head(n = 10) %>%
  collect()

# 5.Count total rows 
vitals_subset %>%
  summarize(n_rows = n()) %>%
  collect()



```

## Q4. AI assistant

Which AI assistants (e.g., GitHub Copilot) do you use when working on this assignment? Which AI model (e.g., GPT-5 mini, GPT-5, Claude Sonnet 4.5) does the AI assistant use? How do you use them? Do you think they help improve your productivity?

Give 5 instances where AI model gave incorrect or misleading answers. You can use screenshots or copy-paste the Q&A.

I used chatgpt and Githubcopilot.

The first example shows how it gave me the wrong answer to my bug problem and the following screenshots show how it couldn't help me get Q3 right with the DB method. I kept feeding it error messages of the vector form not being accepted as well as the table name already existing and nothing it showed me helped, even after 6-7 tries.

![](images/Screenshot 2026-02-11 at 9.13.25 PM-03.png)

![](images/Screenshot 2026-02-11 at 9.13.40 PM-02.png)

![](images/Screenshot 2026-02-11 at 11.17.30 PM.png)

![](images/Screenshot 2026-02-11 at 11.18.14 PM.png)

![](images/Screenshot 2026-02-11 at 11.16.47 PM.png)
